<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.53 Reference Manual: Section A.7</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="clpclp_distinct.html">
<LINK REL=next HREF="clpqr.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="clpclp_distinct.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="clpqr.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:A.7"><SPAN class="sec-nr">A.7</SPAN> <SPAN class="sec-title">clpfd.pl 
-- Constraint Logic Programming over Finite Domains</SPAN></A></H2>

<P><A NAME="sec:clpfd"></A>

<DL>
<DT><B>author</B><DD> Markus Triska
</DL>

<P>Constraint programming is a declarative formalism that lets you 
describe conditions a solution should satisfy. This library provides 
CLP(FD), Constraint Logic Programming over Finite Domains. It can be 
used to model and solve various combinatorial problems such as planning, 
scheduling and allocation tasks.

<P>Most predicates of this library are finite domain <I>constraints</I>, 
which are relations over integers. They generalise arithmetic evaluation 
of integer expressions in that propagation can proceed in all 
directions. This library also provides <I>enumeration</I> <I>predicates</I>, 
which let you systematically search for solutions on variables whose 
domains have become finite. A finite domain <I>expression</I> is one of:
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD>an integer</TD><TD>Given value </TD></TR>
<TR VALIGN=top><TD>a variable</TD><TD>Unknown value </TD></TR>
<TR VALIGN=top><TD>-Expr</TD><TD>Unary minus </TD></TR>
<TR VALIGN=top><TD>Expr + Expr</TD><TD>Addition </TD></TR>
<TR VALIGN=top><TD>Expr * Expr</TD><TD>Multiplication </TD></TR>
<TR VALIGN=top><TD>Expr - Expr</TD><TD>Subtraction </TD></TR>
<TR VALIGN=top><TD>min(Expr,Expr)</TD><TD>Minimum of two expressions </TD></TR>
<TR VALIGN=top><TD>max(Expr,Expr)</TD><TD>Maximum of two expressions </TD></TR>
<TR VALIGN=top><TD>Expr mod Expr</TD><TD>Remainder of integer division </TD></TR>
<TR VALIGN=top><TD>abs(Expr)</TD><TD>Absolute value </TD></TR>
<TR VALIGN=top><TD>Expr / Expr</TD><TD>Integer division </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>The most important finite domain constraints are:
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD>Expr1 <CODE>#&gt;=</CODE> Expr2</TD><TD>Expr1 is 
larger than or equal to Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#=&lt;</CODE> Expr2</TD><TD>Expr1 is 
smaller than or equal to Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#=</CODE> Expr2</TD><TD>Expr1 equals 
Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#\=</CODE> Expr2</TD><TD>Expr1 is not 
equal to Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#&gt;</CODE> Expr2</TD><TD>Expr1 is 
strictly larger than Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#&lt;</CODE> Expr2</TD><TD>Expr1 is 
strictly smaller than Expr2 </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>The constraints <A class="pred" href="clpfd.html##=/2">#=/2</A>, <A class="pred" href="clpfd.html##\=/2">#\=/2</A>, <A class="pred" href="clpfd.html##</2">#&lt;/2</A>, <A class="pred" href="clpfd.html##>/2">#&gt;/2</A>, <A class="pred" href="clpfd.html##=</2">#=&lt;/2</A>, 
and <A class="pred" href="clpfd.html##>=/2">#&gt;=/2</A> can be
<I>reified</I>, which means reflecting their truth values into Boolean 
values represented by the integers 0 and 1. Let P and Q denote reifiable 
constraints or Boolean variables, then:
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>#\</CODE> Q</TD><TD>True iff Q is false </TD></TR>
<TR VALIGN=top><TD>P <CODE>#\/</CODE> Q</TD><TD>True iff either P or Q </TD></TR>
<TR VALIGN=top><TD>P <CODE>#/\</CODE> Q</TD><TD>True iff both P and Q </TD></TR>
<TR VALIGN=top><TD>P <CODE>#&lt;==&gt;</CODE> Q</TD><TD>True iff P and Q 
are equivalent </TD></TR>
<TR VALIGN=top><TD>P <CODE>#==&gt;</CODE> Q</TD><TD>True iff P implies Q </TD></TR>
<TR VALIGN=top><TD>P <CODE>#&lt;==</CODE> Q</TD><TD>True iff Q implies P </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>If a variable occurs at the place of a constraint that is being 
reified, it is implicitly constrained to the Boolean values 0 and 1. 
Therefore, the following queries all fail: <CODE>?-</CODE> <CODE>#\</CODE> 
2. <CODE>?-</CODE> <CODE>#\</CODE> <CODE>#\</CODE> 2. etc.

<P>As an example of a constraint satisfaction problem, consider the 
cryptoarithmetic puzzle SEND + MORE = MONEY, where different letters 
denote distinct integers between 0 and 9. It can be modeled in CLP(FD) 
as follows:

<PRE class="code">
:- use_module(library(clpfd)).

puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-
        Vars = [S,E,N,D,M,O,R,Y],
        Vars ins 0..9,
        all_different(Vars),
                  S*1000 + E*100 + N*10 + D +
                  M*1000 + O*100 + R*10 + E #=
        M*10000 + O*1000 + N*100 + E*10 + Y,
        M #&gt; 0, S #&gt; 0.
</PRE>

<P>Sample query and its result:

<PRE class="code">
?- puzzle(As+Bs=Cs).
As = [9, _G10178, _G10181, _G10184],
Bs = [1, 0, _G10199, _G10178],
Cs = [1, 0, _G10181, _G10178, _G10223],
_G10223 in 2..8,
1000*9+91*_G10178+ -90*_G10181+_G10184+ -9000*1+ -900*0+10*_G10199+ -1*_G10223#=0,
all_different([_G10178, _G10181, _G10184, _G10199, _G10223, 0, 1, 9]),
_G10199 in 2..8,
_G10184 in 2..8,
_G10181 in 5..8,
_G10178 in 4..7.
</PRE>

<P>Here, the constraint solver could deduce more stringent bounds for 
many variables. Labeling can be used to search for solutions:

<PRE class="code">
?- puzzle(As+Bs=Cs), label(As), label(Bs).
As = [9, 5, 6, 7],
Bs = [1, 0, 8, 5],
Cs = [1, 0, 6, 5, 2]
</PRE>

<P>This library also provides <I>reflection</I> predicates (like <A class="pred" href="clpfd.html#fd_dom/2">fd_dom/2</A>,
<A class="pred" href="clpfd.html#fd_size/2">fd_size/2</A> etc.) with 
which you can inspect a variable's current domain. Use <A class="pred" href="coroutining.html#call_residue_vars/2">call_residue_vars/2</A> 
and <A class="pred" href="attvar.html#copy_term/3">copy_term/3</A> to 
inspect residual goals and the constraints in which a variable is 
involved.

<DL>
<DT class="pubdef"><A NAME="in/2"><VAR>?Var</VAR> <STRONG>in</STRONG> <VAR>+Domain</VAR></A></DT>
<DD class="defbody">
Constrain <VAR>Var</VAR> to elements of <VAR>Domain</VAR>. <VAR>Domain</VAR> 
is one of:

<DL>
<DT><VAR><VAR>Lower</VAR></VAR> <STRONG>..</STRONG> <VAR><VAR>Upper</VAR></VAR></DT>
<DD class="defbody">
All integers <I>I</I> such that <I>Lower</I> <CODE>=&lt;</CODE> <I>I</I> <CODE>=&lt;</CODE> <I>Upper</I>. 
The atoms
<B>inf</B> and <B>sup</B> denote negative and positive infinity, 
respectively.
</DD>
<DT><VAR><VAR>Domain1</VAR></VAR> <STRONG><CODE>\/</CODE></STRONG> <VAR><VAR>Domain2</VAR></VAR></DT>
<DD class="defbody">
The union of Domain1 and Domain2.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="ins/2"><VAR>+Vars</VAR> <STRONG>ins</STRONG> <VAR>+Domain</VAR></A></DT>
<DD class="defbody">
Constrain the variables in the list <VAR>Vars</VAR> to elements of <VAR>Domain</VAR>.</DD>
<DT class="pubdef"><A NAME="indomain/1"><STRONG>indomain</STRONG>(<VAR>?Var</VAR>)</A></DT>
<DD class="defbody">
Bind <VAR>Var</VAR> to all feasible values of its domain on 
backtracking. The domain of <VAR>Var</VAR> must be finite.</DD>
<DT class="pubdef"><A NAME="label/1"><STRONG>label</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
Equivalent to labeling([], <VAR>Vars</VAR>).</DD>
<DT class="pubdef"><A NAME="labeling/2"><STRONG>labeling</STRONG>(<VAR>+Options, 
+Vars</VAR>)</A></DT>
<DD class="defbody">
Labeling means systematically trying out values for the finite domain 
variables <VAR>Vars</VAR> until all of them are ground. The domain of 
each variable in <VAR>Vars</VAR> must be finite. <VAR>Options</VAR> is a 
list of options that let you exhibit some control over the search 
process. Several categories of options exist:

<P>The variable selection strategy lets you specify which variable of
<VAR>Vars</VAR> should be labeled next and is one of:

<DL>
<DT><STRONG>leftmost</STRONG></DT>
<DD class="defbody">
Label the variables in the order they occur in <VAR>Vars</VAR>. This is 
the default.
</DD>
<DT><STRONG>ff</STRONG></DT>
<DD class="defbody">
<I>First fail</I>. Label the leftmost variable with smallest domain 
next, in order to detect infeasibility early. This is often a good 
strategy.
</DD>
<DT><STRONG>ffc</STRONG></DT>
<DD class="defbody">
Of the variables with smallest domains, the leftmost one participating 
in most constraints is labeled next.
</DD>
<DT><STRONG>min</STRONG></DT>
<DD class="defbody">
Label the leftmost variable whose lower bound is the lowest next.
</DD>
<DT><STRONG>max</STRONG></DT>
<DD class="defbody">
Label the leftmost variable whose upper bound is the highest next.
</DD>
</DL>

<P>The value order is one of:

<DL>
<DT><STRONG>up</STRONG></DT>
<DD class="defbody">
Try the elements of the chosen variable's domain in ascending order. 
This is the default.
</DD>
<DT><STRONG>down</STRONG></DT>
<DD class="defbody">
Try the domain elements in descending order.
</DD>
</DL>

<P>The branching strategy is one of:

<DL>
<DT><STRONG>step</STRONG></DT>
<DD class="defbody">
For each variable X, a choice is made between X = V and X <CODE>#\=</CODE> 
V, where V is determined by the value ordering options. This is the 
default.
</DD>
<DT><STRONG>enum</STRONG></DT>
<DD class="defbody">
For each variable X, a choice is made between X = V_1, X = V_2 etc., for 
all values V_i of the domain of X. The order is determined by the value 
ordering options.
</DD>
<DT><STRONG>bisect</STRONG></DT>
<DD class="defbody">
For each variable X, a choice is made between X <CODE>#=&lt;</CODE> M 
and X <CODE>#&gt;</CODE> M, where M is the midpoint of the domain of X.
</DD>
</DL>

<P>The order of solutions can be influenced with:

<DL>
<DT><STRONG>min</STRONG>(<VAR>Expr</VAR>)</DT>
<DD class="defbody">
</DD>
<DT><STRONG>max</STRONG>(<VAR>Expr</VAR>)</DT>
<DD class="defbody">
</DD>
</DL>

<P>This generates solutions in ascending/descending order with respect 
to the evaluation of the arithmetic expression Expr. Labeling <VAR>Vars</VAR> 
must make Expr ground. To obtain the incomplete behaviour that other 
systems exhibit with "maximize(Expr)" and "minimize(Expr)", use
<A class="pred" href="metacall.html#once/1">once/1</A>, e.g.:

<PRE class="code">
once(labeling([max(Expr)], Vars))
</PRE>

<P>If more than one option of a category is specified, the one occurring 
rightmost in the option list takes precedence over all others of that 
category. Labeling is always complete, always terminates, and yields no 
redundant solutions.</DD>
<DT class="pubdef"><A NAME="all_different/1"><STRONG>all_different</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
Constrain <VAR>Vars</VAR> to be pairwise distinct.</DD>
<DT class="pubdef"><A NAME="sum/3"><STRONG>sum</STRONG>(<VAR>+Vars, +Op, 
+Expr</VAR>)</A></DT>
<DD class="defbody">
Constrain the sum of a list. The <A class="pred" href="clpfd.html#sum/3">sum/3</A> 
constraint demands that "sumlist(<VAR>Vars</VAR>) <VAR>Op</VAR> <VAR>Expr</VAR>" 
hold, e.g.:

<PRE class="code">
sum(List, #=&lt;, 100)
</PRE>

</DD>
<DT class="pubdef"><A NAME="#>=/2"><VAR>?X</VAR> <STRONG>#&gt;=</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is greater than or equal to <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#=</2"><VAR>?X</VAR> <STRONG>#=&lt;</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is less than or equal to <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#=/2"><VAR>?X</VAR> <STRONG>#=</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> equals <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#\=/2"><VAR>?X</VAR> <STRONG>#\=</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is not <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#>/2"><VAR>?X</VAR> <STRONG>#&gt;</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is greater than <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#</2"><VAR>?X</VAR> <STRONG>#&lt;</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is less than <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#\/1"><STRONG>#\</STRONG> <VAR>+Q</VAR></A></DT>
<DD class="defbody">
The reifiable constraint <VAR>Q</VAR> does <I>not</I> hold.</DD>
<DT class="pubdef"><A NAME="#<==>/2"><VAR>?P</VAR> <STRONG>#&lt;==&gt;</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> and <VAR>Q</VAR> are equivalent.</DD>
<DT class="pubdef"><A NAME="#==>/2"><VAR>?P</VAR> <STRONG>#==&gt;</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> implies <VAR>Q</VAR>.</DD>
<DT class="pubdef"><A NAME="#<==/2"><VAR>?P</VAR> <STRONG>#&lt;==</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>Q</VAR> implies <VAR>P</VAR>.</DD>
<DT class="pubdef"><A NAME="#/\/2"><VAR>?P</VAR> <STRONG>#/\</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> and <VAR>Q</VAR> hold.</DD>
<DT class="pubdef"><A NAME="#\//2"><VAR>?P</VAR> <STRONG>#\/</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> or <VAR>Q</VAR> holds.</DD>
<DT class="pubdef"><A NAME="lex_chain/1"><STRONG>lex_chain</STRONG>(<VAR>+Lists</VAR>)</A></DT>
<DD class="defbody">
Constrains <VAR>Lists</VAR> to be lexicographically non-decreasing.</DD>
<DT class="pubdef"><A NAME="tuples_in/2"><STRONG>tuples_in</STRONG>(<VAR>+Tuples, 
+Relation</VAR>)</A></DT>
<DD class="defbody">
<VAR>Relation</VAR> is a ground list of lists of integers. The elements 
of the list <VAR>Tuples</VAR> are constrained to be elements of <VAR>Relation</VAR>.</DD>
<DT class="pubdef"><A NAME="all_distinct/1"><STRONG>all_distinct</STRONG>(<VAR>+Ls</VAR>)</A></DT>
<DD class="defbody">
Like <A class="pred" href="clpfd.html#all_different/1">all_different/1</A>, 
with stronger propagation.</DD>
<DT class="pubdef"><A NAME="serialized/2"><STRONG>serialized</STRONG>(<VAR>+Starts, 
+Durations</VAR>)</A></DT>
<DD class="defbody">
Constrain a set of intervals to a non-overlapping sequence.
<VAR>Starts</VAR> = [S_1,...,S_n], is a list of variables or integers,
<VAR>Durations</VAR> = [D_1,...,D_n] is a list of non-negative integers. 
Constrains <VAR>Starts</VAR> and <VAR>Durations</VAR> to denote a set of 
non-overlapping tasks, i.e.: S_i + D_i <CODE>=&lt;</CODE> S_j or S_j + 
D_j <CODE>=&lt;</CODE> S_i for all 1 <CODE>=&lt;</CODE> i <VAR>&lt;</VAR> 
j <CODE>=&lt;</CODE> n.

<DL>
<DT><B>See also</B><DD> Dorndorf et al. 2000, "Constraint Propagation 
Techniques for the Disjunctive Scheduling Problem"
</DL>

</DD>
<DT class="pubdef"><A NAME="fd_var/1"><STRONG>fd_var</STRONG>(<VAR>+Var</VAR>)</A></DT>
<DD class="defbody">
True iff <VAR>Var</VAR> is a CLP(FD) variable.</DD>
<DT class="pubdef"><A NAME="fd_inf/2"><STRONG>fd_inf</STRONG>(<VAR>+Var, 
-Inf</VAR>)</A></DT>
<DD class="defbody">
<VAR>Inf</VAR> is the infimum of the current domain of <VAR>Var</VAR>.</DD>
<DT class="pubdef"><A NAME="fd_sup/2"><STRONG>fd_sup</STRONG>(<VAR>+Var, 
-Sup</VAR>)</A></DT>
<DD class="defbody">
<VAR>Sup</VAR> is the supremum of the current domain of <VAR>Var</VAR>.</DD>
<DT class="pubdef"><A NAME="fd_size/2"><STRONG>fd_size</STRONG>(<VAR>+Var, 
-Size</VAR>)</A></DT>
<DD class="defbody">
<VAR>Size</VAR> is the number of elements of the current domain of <VAR>Var</VAR>, 
or the atom <B>sup</B> if the domain is unbounded.</DD>
<DT class="pubdef"><A NAME="fd_dom/2"><STRONG>fd_dom</STRONG>(<VAR>+Var, 
-Dom</VAR>)</A></DT>
<DD class="defbody">
<VAR>Dom</VAR> is the current domain (see <A class="pred" href="clpfd.html#in/2">in/2</A>) 
of <VAR>Var</VAR>.
</DD>
</DL>

<P></BODY></HTML>